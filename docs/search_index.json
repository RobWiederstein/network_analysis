[["index.html", "Network Analysis in R Preface 0.1 Why Read this Book 0.2 Purpose 0.3 Collection 0.4 Prerequisites 0.5 Disclaimer 0.6 Acknowledgements", " Network Analysis in R Robert Wiederstein 2021-01-19 Preface 0.1 Why Read this Book Network analysis is a crucial strategy in understanding the direction and strength of connections between people, places and ideas. Visual representation of networks can speed the discovery process in working with data. It has a wide variety of applications and has been used to study social media like twitter, (Grandjean 2016), dispersion of knowledge among inventors, (Brennecke and Rank 2017) and the transmission of disease (Emch et al. 2012) , to name just a few. The imagination of researchers to adopt social network analysis to new paradigms have left academic veterans reluctant to define its terms narrowly. (Easley and Kleinberg 2012) 0.2 Purpose The purpose of this book is to speed the conversion of a traditional dataframe to a network diagram with nodes and vertices. Some discusson of basic computations will be included, but formulas are omitted unless necessary for understanding. Network analysis is challenging partially due to its reliance on unfamiliar data structures. 0.3 Collection What follows is admittedly not the most original or insightful work on networks. It is an attempt to collect tutorials from disparate packages, software and websites in a single place. Attribution will, of course, be given where known. 0.4 Prerequisites A working knowledge of R is necessary including how to obtain and load packages, how to manipulate basic data structures like lists and dataframes and how to plot and save graphs in multiple formats. Methods and packages in the tidyverse are preferred where available and Rstudio is the development environment of choice. 0.5 Disclaimer I have no education or background in statistics, informatics or network analysis. Reliance upon any representation within this publication should occur, if at all, only after verification from other reliable sources and in consultation with someone with a relevant background. 0.6 Acknowledgements There were a number of helpful tutorials that deserve explicit mention and public acclaim. The authors’ differing perspectives gave context on how best to learn network analysis with igraph. They include: Katherine Ognyanova, Network Analysis and Visualization with R and igraph Jesse Sadler, Introduction to Network Analysis with R David Schoch, Basic Network Analysis in R: using igraph and related packages Network Visualization Cookbook Janpu Hou, Network Visualization by igraph References "],["intro.html", "Chapter 1 Introduction 1.1 Terms 1.2 Understanding igraph Summary 1.3 Creating Graphs 1.4 Manipulating Graphs 1.5 Input formats 1.6 Datasets 1.7 Sanity Checks", " Chapter 1 Introduction Package downloads are a proxy for the need for or the success of a package. As of December, 2020, total packages for R numbered 16,851 and 385 packages used the word “network” in the title. The latest monthly downloads yielded both total downloads and a clear leader in the area of network analysis: igraph. The two plots below show igraph downloads to other packages. Figure 1.1: The plot above shows the number of downloads for all packages and igraph. Figure 1.2: Top 10 packages with ‘network’ in their title. Packages dealing with computer networks like ‘RCurl’ were omitted. 1.1 Terms “A network is not just a metaphor: it is a precise, mathematical construct of nodes (vertices, actors) N and edges (ties, relations) E that can be directed or undirected. We can include information (attributes) on the nodes as well as the edges.” (Jasney 2018) Figure 1.3: A network consisting of nodes, N, and directed edges E. 1.2 Understanding igraph Summary The “karate” dataset is “a social network between members of a university karate club, led by president John A. and karate instructor Mr. Hi, which are pseudonyms. Sending the”karate&quot; object to the console yields the output below: Understanding the console output above is critical to the comprehension of the graph object. Rote memorization will speed the use of igraph and graph production. The first line identifies the object as an igraph graph and then there is 4 character letter-based code. The first character is assigned either a “D” or a “U” which indicates whether the graph is directed or undirected. The second letter is either an “N” or a dash (“-”) depending on whether the graph is “N”amed or not. The third letter is either a “W” or a dash depending on if it is weighted. And finally, the fourth character can be a “B” for bipartite or a dash. The two numbers indicate the number of vertices and edges. Here, 34 nodes and 78 vertices comprise the “karate” club. Immediately adjacent to it is the name of the data set, “Zachary’s Karate Club”. And thereafter is the list of the node and vertex attributes. Lastly, the edges of the graph are listed. The parenthetical following the “+attr” tag can take on one of three values: “g” for graph, “v” for vertices and “e” for edge. The character following the forward slash within the parentheses can take on one of three values too and refers to data types within R: “n” for numeric, “c” for character, “l” for logical. The actual data can be seen by querying with E(graphObject) and V(graphObject). E(karate)[1:5] ## + 5/78 edges from 4b458a1 (vertex names): ## [1] Mr Hi--Actor 2 Mr Hi--Actor 3 Mr Hi--Actor 4 Mr Hi--Actor 5 Mr Hi--Actor 6 and V(karate)[1:5] ## + 5/34 vertices, named, from 4b458a1: ## [1] Mr Hi Actor 2 Actor 3 Actor 4 Actor 5 1.3 Creating Graphs There are many ways to create a graph using igraph. In his book on igraph, author Csardi grouped a graph’s creation into (1) predefined structures, i.e. make_star(), (2) conversion of graph structures, ie. graph_from_literal(), (3) sample random graph models, i.e. sample_gnp() and (4) read_graph(). The code below lists possible ways to create a graph. In illustrating igraph functions, many of the graphs creation methods wil be used in subsequent chapters. grep(&quot;^make|^graph_|^sample_&quot;, lsf.str(&quot;package:igraph&quot;), value = T) 1.4 Manipulating Graphs diamond &lt;- make_graph(&quot;Diamond&quot;) plot(diamond) diamond ## IGRAPH 8084107 U--- 4 5 -- Diamond ## + attr: name (g/c) ## + edges from 8084107: ## [1] 1--2 1--3 2--3 2--4 3--4 diamond[] ## 4 x 4 sparse Matrix of class &quot;dgCMatrix&quot; ## ## [1,] . 1 1 . ## [2,] 1 . 1 1 ## [3,] 1 1 . 1 ## [4,] . 1 1 . diamond$name ## [1] &quot;Diamond&quot; V(diamond) ## + 4/4 vertices, from 8084107: ## [1] 1 2 3 4 E(diamond) ## + 5/5 edges from 8084107: ## [1] 1--2 1--3 2--3 2--4 3--4 V(diamond)$name &lt;- LETTERS[1: vcount(diamond)] E(diamond)$weight &lt;- 1:ecount(diamond) plot(diamond, edge.width = E(diamond)$weight) diamond ## IGRAPH 8084107 UNW- 4 5 -- Diamond ## + attr: name (g/c), name (v/c), weight (e/n) ## + edges from 8084107 (vertex names): ## [1] A--B A--C B--C B--D C--D g &lt;- make_bipartite_graph( rep(0:1,length=10), c(1:10)) print(g, v=TRUE) ## IGRAPH a5a94d3 U--B 10 5 -- ## + attr: type (v/l) ## + edges from a5a94d3: ## [1] 1-- 2 3-- 4 5-- 6 7-- 8 9--10 plot(g) V(g) ## + 10/10 vertices, from a5a94d3: ## [1] 1 2 3 4 5 6 7 8 9 10 E(g) ## + 5/5 edges from a5a94d3: ## [1] 1-- 2 3-- 4 5-- 6 7-- 8 9--10 1.5 Input formats Building a network graph is challenging because of the number of potential input types. Users must first distinguish whether the input is an adjacency matrix, incidence matrix, or edge list. Then, the user must know if the graph is directed or undirected, weighted or unweighted. (Holtz 2020) 1.5.1 Adjacency matrix An adjacency matrix is a square matrix where the number of rows and columns are the same. igraph can read an adjacency matrix using the graph_from_adjacency_matrix() function. Table 1.1: Adjacency Matrix. A ‘0’ denotes no connection. A B C D E F A 0 1 0 0 0 0 B 0 0 0 0 0 0 C 0 0 0 1 0 0 D 1 0 0 0 0 0 E 0 0 0 0 2 2 F 2 0 1 0 0 0 Figure 1.4: Network plot from adjacency matrix 1.5.2 Sparse matrix The function, graph_from_adjacency_matrix(), also accepts a sparse matrix which is sometimes preferred to minimize file sizes and conserve system resources on large datasets. ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## ## [1,] . . 1 1 1 ## [2,] 1 1 1 . . ## [3,] 1 . . . 1 ## [4,] 1 1 1 . . ## [5,] 1 . 1 . 1 Figure 1.5: Network plot from sparse matrix. 1.5.3 Incidence matrix The rows and columns of an incidence matrix do not have to be equal. Its shape can be rectangular in addition to square. igraph can read an incidence matrix using the graph_from_incidence_matrix(). Table 1.2: Example incidency matrix. a b c d e A 0 2 0 2 0 B 2 1 0 0 1 C 0 1 1 2 0 D 1 2 1 0 0 E 0 2 1 0 1 F 2 0 1 0 1 Figure 1.6: Network plot from incidency matrix. 1.5.4 Edge list An edge list has 2 columns. Each observation represents a connection between two things. The two column names are alternatively named (1) an origin and a destination or (2) a source and target, depending on the package used. The correct column names are often the key to a successful importation of the data in many applications. igraph imports an edge list graph_from_edgelist() function. Table 1.3: Example Edgelist. origin destination A C D A A E B E E B C F F F B B C A Figure 1.7: Plot generated from edgelist. 1.5.5 Dataframe distinguished “A data frame may for many purposes be regarded as a matrix with columns possibly of differing modes and attributes.” (R Core Team 2020) In other words, a matrix must contain all of the same data type while a dataframe can have columns with differing data types – numeric, character, factor, etc. Different authors and packages require one or the other and many coerce to the required data type internally without notification to the user. Matrices may offer greater computational efficiency although it may depend on the data types included. (find cite) 1.6 Datasets igraphdata contains a number of datasets that illustrate the use of network analysis. The command data(package=&quot;igraphdata&quot;) lists the datasets available. After loading the package, data(&quot;karate&quot;) will load, for example, the “karate” dataset. Table 1.4: Datasets included in igraphdata package. Item Title Koenigsberg Bridges of Koenigsberg from Euler’s times UKfaculty Friendship network of a UK university faculty USairports US airport network, 2010 December enron Enron Email Network foodwebs A collection of food webs immuno Immunoglobulin interaction network karate Zachary’s karate club network kite Krackhardt’s kite macaque Visuotactile brain areas and connections rfid Hospital encounter network data yeast Yeast protein interaction network 1.7 Sanity Checks A “sanity check” in coding is a method to determine if an error is the result of the code or the data used. It’s probably a safe presumption that a dataset resident within a package is formatted correctly. However, it may be helpful to check user-built data structures in a program like Gephi or Cytoscope. Both Gephi and Cytoscope require some familiarity before use. References "],["igraph.html", "Chapter 2 igraph 2.1 Examples 2.2 Layout of Nodes 2.3 Attributes", " Chapter 2 igraph igraph contains 773 functions. Three different plotting mechanisms exist: igraph for two dimensional plots, tkplot for interactive 2-dimensional plotting and rglplot which is for 3-dimensional plotting and is labeled as “experimental.” The igraph functions for two dimensional plots is the focus for the next * chapters. 2.1 Examples 2.1.1 Simple Graphs The simple graph below was created from manual entry using igraph’s graph_from_literal function. Figure 2.1: Graph (a) is two nodes connected by edge, graph (b) is two unconnected nodes, graph (c) is two nodes with a directional edge, graph (d) is two nodes with the directional edge reversed, graph (e) is two nodes with a bidirectional edge, and graph (f) is two nodes connected by a weighted edge. 2.1.2 Notable Graphs Figure 2.2: Nine of 31 ‘Notable Graphs’ from ’make_graph()` 2.1.3 Complicated Graph The complicated graph below was created from the Les Miserable resident dataset in igraph. (Knuth 1993) The data contains 77 nodes and 254 edges. Figure 2.3: Network graph of the coappearnce of characters in Les Miserable. 2.2 Layout of Nodes Nodes may be laid out in a variety of ways and many algorithms are available, depending on the data and the analyst’s personal preference. “It is important to realize that the information in graph layouts is contained in the pattern of which nodes are connected to which others. The locations . . . are chosen based on essentially aesthetic criteria.” (Borgatti, Everett, and Johnson 2018) 2.2.1 Consistent Plotting Many of the igraph layouts are generated through an algorithm and the coordinates change each time it is plotted. To keep the appearance the same, the set.seed() function must be set. set.seed(1234) house &lt;- make_graph(&quot;house&quot;) plot.igraph(house) A second method to retain consistency in plotting is to retain the coordinates in a separate variable as opposed to the set.seed() strategy. data(&quot;UKfaculty&quot;) coords &lt;- layout_with_fr(UKfaculty, niter = 1000) par(mfrow=c(1, 2)) par(oma=c(0,0,2,0)) plot.igraph(UKfaculty, layout = coords, main = &quot;layout = coords #1&quot;, vertex.color = &quot;blue&quot;) plot.igraph(UKfaculty, layout = coords, main = &quot;layout = coords #2&quot;, vertex.color = &quot;red&quot;) 2.2.2 Available Layouts According to the igraph documentation, 21 available layouts are available and include: Table 2.1: Available layouts for nodes in igraph. add_layout_ component_wise layout_as_star layout_as_tree layout_in_circle layout_nicely layout_on_grid layout_on_sphere layout_randomly layout_with_dh layout_with_fr layout_with_gem layout_with_graphopt layout_with_kk layout_with_lgl layout_with_mds layout_with_sugiyama layout_ merge_coords norm_coords normalize Plots were randomly generated from an adjacency matrix as illustrated by R-graph-gallery. The layout_nicely function is the default. (verify). The function uses the layout_with_fr with graphs less than 1,000 vertices and the layout_with_drl for graphs greater than 1,000 vertices. Figure 2.4: Examples of available layouts. In plotting graphs with many nodes, the chosen layout will result in overlapping nodes. The challenge is in spreading the nodes out to the space available. One strategy was described in a stackoverflow question using the qgraph library. The code was was used to reproduce the plot below. Figure 2.5: Node dispersion of the Fruchterman-Reingold (F-R) layout. 2.3 Attributes Any chart is comprised of geoms. igraph allows for the color, size, shape to be set in of two ways. The first method is to supply named arguments to the plotting command, in the this case plot.igraph. The second method is to set the attributes via assignment to the vertex, edge or graph. According to the manual, assignments using the second method do not require “vertex” or “edge” to be prepended. Graph attributes are listed anytime the graph object is sent to the console. See section *. Othewise, attributes of the graph, vertices, and edges can be determed through three functions: (1) list.graph.attributes, (2) list.vertex.attributes, and (3) list.edge.attributes. The function length can be cumbersome and the following function may be helpful in list all of them at once. (???) # get_igraph_attrs &lt;- function(igraph){ if(!is_igraph(igraph)) stop(&quot;Not a graph object&quot;) list(graph_attrs = list.graph.attributes(igraph), vertex_attrs = list.vertex.attributes(igraph), edge_attrs = list.edge.attributes(igraph)) } get_igraph_attrs(UKfaculty) #First Method -- supply named arguments to plot plot.igraph(make_graph(&quot;Bull&quot;), vertex.shape = &quot;square&quot; ) #Second Method -- set vertex attributes g &lt;- make_graph(&quot;Bull&quot;) %&gt;% set_vertex_attr(name = &quot;shape&quot;, value = &quot;square&quot;) 2.3.1 Vertices Figure 2.6: Selected node attributes. Figure 2.7: Additional node color palettes. 2.3.1.1 Shapes 2.3.1.2 Sizes 2.3.1.3 Colors The argument to set the vertex color in the plot.igraph function is vertex.color. Like plots in base R, color may be set by a number (integer) or name (character) with the name being preferred. The default palette can be retrieved through ?igraph::categorical_pal(n). The colors are visible to those who are color-blind and is eight colors. For plot.igraph and integer values, the default igraph palette is used (see the ‘palette’ parameter below. Note that this is different from the R palette. If you don’t want (some) vertices to have any color, supply NA as the color name. The default value is “SkyBlue2”. 2.3.2 Edges Figure 2.8: Selected edge attributes. References "],["modification.html", "Chapter 3 Graph Modification 3.1 Load plot “House” 3.2 Get Edges 3.3 Get Vertices", " Chapter 3 Graph Modification 3.1 Load plot “House” g1 &lt;- make_graph(&quot;house&quot;) #data structure - full g1[] ## 5 x 5 sparse Matrix of class &quot;dgCMatrix&quot; ## ## [1,] . 1 1 . . ## [2,] 1 . . 1 . ## [3,] 1 . . 1 1 ## [4,] . 1 1 . 1 ## [5,] . . 1 1 . #data structure - row 1 g1[1, ] ## [1] 0 1 1 0 0 #data structure - col 2 g1[, 2] ## [1] 1 0 0 1 0 par(mfrow = c(1, 2)) #plot graph object plot(g1, vertex.size = 30, vertex.color = 1, #default main = &quot;Our House&quot; ) #assign attribute &amp; label nodes vertex_attr(g1, name = &quot;rooms&quot;) &lt;- c(&quot;LR&quot;, &quot;FR&quot;, &quot;BR&quot;, &quot;DR&quot;, &quot;Garage&quot;) plot(g1, vertex.size = 30, vertex.color = 1, vertex.label = V(g1)$rooms, main = &quot;Has Many Rooms&quot; ) 3.2 Get Edges # &quot;E&quot; is for edges E(g1) ## + 6/6 edges from f3f05b7: ## [1] 1--2 1--3 2--4 3--4 3--5 4--5 edge_attr(g1, name = &quot;services&quot;) &lt;- c(&quot;electric&quot;, &quot;air_cond&quot;, &quot;gas&quot;, &quot;cable&quot;, &quot;wifi&quot;, &quot;water&quot;) par(mfrow = c(1, 2)) plot(g1, vertex.size = 30, vertex.color = 1, vertex.label = V(g1)$rooms, main = &quot;With Many Rooms&quot; ) plot(g1, vertex.size = 30, vertex.color = 1, vertex.label = V(g1)$rooms, edge.label = E(g1)$services, main = &quot;Is Connected&quot; ) 3.3 Get Vertices # &quot;V&quot; is for vertices V(g1) ## + 5/5 vertices, from f3f05b7: ## [1] 1 2 3 4 5 3.3.1 Add vertices attribute V(g1)$label &lt;- letters[1:length(V(g1))] #query attibutes vertex_attr(g1) ## $rooms ## [1] &quot;LR&quot; &quot;FR&quot; &quot;BR&quot; &quot;DR&quot; &quot;Garage&quot; ## ## $label ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; #set_vertex_attr(g1, name = &quot;size&quot;, value = seq(10, 50, by =10)) V(g1)$size &lt;- seq(10, 50, by = 10) plot(g1) "],["first-graphs.html", "Chapter 4 First Graphs 4.1 Les Miserable Dataset 4.2 Stop light 4.3 Les Miserabe", " Chapter 4 First Graphs 4.1 Les Miserable Dataset # Load igraph library(igraph) # Read data lesmis &lt;- read.csv(&quot;https://raw.githubusercontent.com/meefen/sna-ed/master/assets/lesmis/lesmis.csv&quot;) # check the head (first 6 rows) of the dataset head(lesmis) ## Source Target weight ## 1 1 0 1 ## 2 2 0 8 ## 3 3 0 10 ## 4 3 2 6 ## 5 4 0 1 ## 6 5 0 1 # Create a graph using the graph_from_data_frame function g &lt;- graph_from_data_frame(lesmis) # Plot the graph plot(g) # make the graph a little prettier plot(g, edge.arrow.size=.2, vertex.label=NA, vertex.size=8) 4.2 Stop light library(sigmajs) library(tibble) edges &lt;- tibble(id = rep(&quot;1&quot;, 3), source = rep(&quot;1&quot;, 3), target = as.character(c(2:4)) ) nodes &lt;- tibble(id = as.character(1:4), label = c(&quot;light&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;), time = c(100, 30, 10, 20) ) sigmajs() %&gt;% sg_nodes(nodes, id, label, time) %&gt;% sg_edges(edges, id, source, target) 4.3 Les Miserabe "],["filter-and-group.html", "Chapter 5 Filter and Group 5.1 Pruning 5.2 Grouping", " Chapter 5 Filter and Group Important tasks in network analysis include omitting insignificant or nominal connections from a graph while highlighting and emphasizing others. 5.1 Pruning Pruning is the process of eliminating insignifant or nominal connections from the network graph. There are many methods available and only the simplest of strategies are employed here. The example here is Zachary’s karate club, a resident dataset in the igraphdata package. More information may be found by entering ?igraphdata::karate. g1 &lt;- sample_pa(80) l &lt;- layout_with_fr(g1) l &lt;- norm_coords(l, ymin=-1, ymax=1, xmin=-1, xmax=1) par(mar=c(0,0,0,0)) plot(g1, rescale=F, layout=l*1.0) data(&quot;karate&quot;) karate.new &lt;- delete_edges(karate, E(karate)[weight&lt;=3]) par(mfrow = c(1, 3), mar = c(1,1,1,1)) plot(karate, vertex.label = NA, vertex.color = 1) hist(E(karate)$weight) plot(karate.new, vertex.label = NA, vertex.color = 1) 5.2 Grouping Grouping is the process of associating nodes together via "],["sigma.html", "Chapter 6 Sigma JS 6.1 Stop light", " Chapter 6 Sigma JS #example for ?sigmajs::sigmajs library(sigmajs) nodes &lt;- sg_make_nodes() edges &lt;- sg_make_edges(nodes) sigmajs() %&gt;% sg_nodes(nodes, id, label, size, color) %&gt;% sg_edges(edges, id, source, target) 6.1 Stop light library(sigmajs) library(tibble) edges &lt;- tibble(id = rep(&quot;1&quot;, 3), source = rep(&quot;1&quot;, 3), target = as.character(c(2:4)) ) nodes &lt;- tibble(id = as.character(1:4), label = c(&quot;light&quot;, &quot;red&quot;, &quot;yellow&quot;, &quot;green&quot;), time = c(100, 30, 10, 20) ) sigmajs() %&gt;% sg_nodes(nodes, id, label, time) %&gt;% sg_edges(edges, id, source, target) "],["starwars.html", "Chapter 7 Case Study – Star Wars 7.1 Read Data 7.2 Graph object error 7.3 Create attributes 7.4 Final plot 7.5 Summary", " Chapter 7 Case Study – Star Wars The coappearance of Star Wars characters across the seven episodes was collected by data scientist Evelina Gabasova and her analysis can be found here. The individual nodes represent characters in the movies. The characters are connected if they speak together in a scene. The width of the edges is set by how much the characters speak to one another. The size of each node represents the number of scenes that the characters appear in together. Dr. Gabasova separated the two characters Darth Vader and Anakin from one another, yet combined Palpatine and Darth Sidious in a single node. Amidala was merged with Padme. The data is available as a github repo.(Gabasova 2016) Figure 7.1: Gabasova’s Starwars social network plot was prepared with D3.js In this chapter, the above plot will be recreated using the Star Wars dataset, all seven episodes, using R and igraph. The dataset was downloaded from the repo and is saved at ./data/gabasova/starwars-full-interactions-allCharacters.json. 7.1 Read Data The data were stored in a json file and required importation using the jsonlite package. Once imported, the dataframes were clearly marked. “Links” was changed to “edges”. There were 112 characters in the seven Star Wars episodes with 450 character interactions. #import file txt &lt;- &quot;./data/gabasova/starwars-full-interactions-allCharacters.json&quot; star.wars &lt;- jsonlite::fromJSON(txt = txt) #json was list of two databases: nodes and edges nodes &lt;- star.wars$nodes edges &lt;- star.wars$links 7.2 Graph object error When the function graph_from_data_frame() was applied to the dataframe, an error message was displayed. #create graph object from dataframe--attempt 1 g &lt;- igraph::graph_from_data_frame(d = edges, directed = F, vertices = nodes ) ## Error in igraph::graph_from_data_frame(d = edges, directed = F, vertices = nodes): Some vertex names in edge list are not listed in vertex data frame Upon creating a separate column labeled “id” and setting its value beginning with “0”, the error did not repeat when the graph object was created. #Nodes--need to adjust column for 0-based index nodes$id &lt;- 0:111 #add id column nodes &lt;- dplyr::relocate(nodes, id, name, value, colour) #create graph object from dataframe -- attempt 2 g &lt;- igraph::graph_from_data_frame(d = edges, directed = F, vertices = nodes ) 7.3 Create attributes Gabasova’s original plot allowed for width to vary depending on the talk or conversation between the characters. The range of those conversations was between 1 to 77. Efforts to assign edge width based on the absolute values yield non-sensical widths. Instead, a new attribute column was created by cutting the value column into six intervals. #Edges: create column for edge.width attribute edges$talk &lt;- ggplot2::cut_interval(edges$value, 6) levels(edges$talk) &lt;- as.character(1:6) edges$talk &lt;- as.integer(edges$talk) Additionally, in Gabasova’s original plot, the size of the node varies with the number of scenes that the characters appear in together. The nodes dataframe contains a column listed as value. A new column was created for the vertex.size argument where the interval was cut into six equal sizes. #Nodes: create column for vertex.size attribute nodes$scenes &lt;- ggplot2::cut_interval(nodes$value, 6) levels(nodes$scenes) &lt;- 1:6 nodes$scenes &lt;- as.character(nodes$scenes) 7.4 Final plot #Create method to spread nodes e &lt;- edges[, c(1, 2)]#get.edgelist(g) l &lt;- qgraph.layout.fruchtermanreingold(e,vcount=vcount(g)) #plot the graph par(mar = c(0,0,0,0)) plot(g, layout = qgraph.layout.fruchtermanreingold(e, vcount = vcount(g), area = 8 * (vcount(g) ^ 1), repulse.rad = (vcount(g) ^ 1) ), vertex.color = vertex.attributes(g)$colour, vertex.label = ifelse(V(g)$value &gt; 35, V(g)$name, NA), vertex.label.color = &quot;black&quot;, vertex.label.cex = .6, vertex.label.font = 2, vertex.size = as.integer(vertex.attributes(g)$scenes) * 2, vertex.frame.color=&quot;white&quot;, edge.width = edge.attributes(g)$talk * 1, edge.color = &quot;#D3D3D3&quot;, asp = 0 ) 7.5 Summary The Star Wars characters dataset is similar to the “Les Mis” dataset in that both track the coappearance of characters in famous artistic works one historic from 1584 and one contemporary beginning in 1977. The Star Wars dataset offered more in terms of variables and the colour of the nodes was furnished. The error discussed above was included as it occurs with some frequency that edges and vertices fail to match. It is the subject of several questions on StackOverflow. The entire script describe above is included in the repo as ./R/recreate_gabasova_star_wars_graph.R Overall, the graph as rendered in igraph matched most of the features of the D3 graph by Gabasova. One issue that was unresolved was the labels in igraph did not seem so allow the individual “tweaking” that occurred in the first chart. Nonetheless, the Star Wars data allowed for many of the previous concepts to be applied and expanded, making it an excellent case study for skill development. References "],["irs.html", "Chapter 8 Case Study – SOI Tax Stats 8.1 County-to-county Outflow data 8.2 Read Data 8.3 First Plot 8.4 Open the Space 8.5 Set Variable for Vertex Size 8.6 Set Vertex Color 8.7 Layout of nodes", " Chapter 8 Case Study – SOI Tax Stats The IRS provides information on migration from IRS tax forms. Its Migration Data Users guide “provides a detailed description of the State-to-State, County-to-County, and Gross Migration files produced by the Internal Revenue Service (IRS) Statistics of Income (SOI) Division. IRS Migration data for the United States are based on year-to-year address changes reported on individual income tax returns filed with the IRS. They present migration patterns by State or by county and are available for inflows—the number of new residents who moved to a State or county and where they migrated from, and outflows—the number of residents leaving a State or county and where they went. The data also include tabulations on the number of non-migrant returns within a State or county.” The latest year available was for 2017-2018. 8.1 County-to-county Outflow data “The County-to-County outflow migration files represent the migration flows from the origin state and county, in year one, to the destination state and county, in year two. There are 51 files for each state plus the District of Columbia. Included in the list of county flows are the number of returns that migrated to a foreign location [4]. The migration flows include the following county equivalents (Parishes in Louisiana, Boroughs, Census Areas, and municipalities in Alaska, independent cities, such as Baltimore, Maryland, and the District of Columbia).” 8.2 Read Data The data was prepared prior to import in the book here. The data represent return filers whose address changed from Miami-Dade county in year one to some other county in year 2. Additionally, only counties that received greater than 100 new residents from Miami were included. # import edges &lt;- data.table::fread(&quot;./data/irs/miami-out-migration-edges.csv&quot;) nodes &lt;- data.table::fread(&quot;./data/irs/miami-out-migration-nodes.csv&quot;) # create network g1 &lt;- igraph::graph_from_data_frame(d = edges, directed = T, vertices = nodes ) #remove self-loops, people that moved w/in county g1 &lt;- simplify(g1, remove.multiple = F, remove.loops = T ) 8.3 First Plot It’s usually a good idea to see if the data will plot first so that any residual and obvious problems can be addressed. Here, a graph object was successfully created and plotted with plot(g1). Figure 8.1: A plot using igraph defaults. 8.4 Open the Space The plot above is unreadable when rendered with igraph defaults, but shows the importance of formatting. It also shows the difficulty of trying to make sense of the data when it is jumbled. The next step is to simplify the plot so that the formatting process can begin. Three suggestions are to omit labels, reduce vertex size and minimize arrow size. Figure 8.2: Formatting arguments to open graphing space. 8.5 Set Variable for Vertex Size Vertex size is a graph attribute that is often scaled to a variable. Here, the size is scaled to the number of returns or persons who moved from Maimi-Dade County. The node$returns variable was cut into quintiles of equal size and assigned to a new column as quintile. Since the nodes dataframe was changed, it must be converted again into a new graph object. #create variable for vertex.size -- cut number returns into 5 nodes$quintile &lt;- ggplot2::cut_number(nodes$returns, n = 5) levels(nodes$quintile) &lt;- 1:5 nodes$quintile &lt;- as.character(nodes$quintile) nodes$quintile &lt;- as.integer(nodes$quintile) 8.6 Set Vertex Color The color of the node is often a prominent attribute that can contribute to the understanding of the graph. Five colors were assigned to each of the quintiles of the returns from the vidiris package. Thus, nodes that are large in size realtive to the other nodes and colored yellow are featured prominently in the graph. These are the counties that received the highest numbers of out-migration from Miami-Dade. #create node color palette and merge w/ node df my.colors &lt;- tibble(quintile = 1:5, colors = viridis(5, option = &quot;D&quot;) ) nodes &lt;- dplyr::left_join(nodes, my.colors, by = &quot;quintile&quot;) Figure 8.3: Node attributes set for size and color. 8.7 Layout of nodes g4 &lt;- igraph::graph_from_data_frame(d = edges, directed = F, vertices = nodes ) plot(g4, vertex.label = NA, vertex.size = V(g3)$quintile ^2, vertex.color = V(g3)$colors, edge.arrow.size = .1, main = &quot;vertex.color&quot; ) par(mfrow=c(1,2)) # Community detection based on label propagation: clp &lt;- cluster_label_prop(g4) class(clp) ## [1] &quot;communities&quot; # Community detection returns an object of class &quot;communities&quot; # which igraph knows how to plot: plot(clp, g4, vertex.label = NA, vertex.size = V(g3)$quintile ^2, vertex.color = V(g3)$colors, edge.arrow.size = .1, main = &quot;vertex.color&quot; ) # We can also plot the communities without relying on their built-in plot: V(g4)$community &lt;- clp$membership "],["airlines.html", "Chapter 9 Case Study – Airlines", " Chapter 9 Case Study – Airlines There were several examples dealing with airlines. Flowing data has a tutorial where Yau cleaned a dataset. The article’s title is “Geographic breakdown: Where do major airlines fly?”. A second dataset is from Gephi and is contained in data/gephy/airlines.graphml.zip. Yet a third is a script where I downloaded airline data from Bureau of Transportation Statistics. I opened a separate project in my r-projects directory. It can be found at ~/Dropbox/coding/rproj/airlines. A fourth script is here with a randomly generated graph object and 15 countries "],["riband.html", "Chapter 10 Case Study – Blue Riband 10.1 Introduction 10.2 Igraph 10.3 Geosphere 10.4 NetworkD3 Package", " Chapter 10 Case Study – Blue Riband 10.1 Introduction The “Blue Riband” was a recognition given to the passenger ship that maintained the highest average speed across the northern Atlantic Ocean. The prize was not regularly awarded but rather as a ship bested a previous record. Some years contained more than one blue riband winner while others had none. Table 10.1: Winners by Country flag wins GBR 87 DEU 17 USA 7 FRA 5 ITA 1 The west-bound trip typically originated from Western Europe and ended in New York harbor which is reported as “Sandy Hook”, “Ambrose Lightship”, “Ambrose” or just plain “New York”. It was considered the more difficult journey as the Gulf Stream water currents slowed ship speeds. Ships that won the riband on the western route typically won it on the eastern trip as well. For perspective, trips across the Atlantic in the late 1700s and early 1800s lasted several weeks with one traveler reporting a trip of 57 days. The advent of the steamship and its inclusion into ships resulted in faster times and more consistency in trip duration. Like more contemporary national contests–space and aeronatics, the winning of the blue riband was a source of national pride and a public demonstration of a nation’s technology prowess. The contests lasted from 1854 to 1952 and the ships crossed the Atlantic in ever faster times and speeds. Figure 10.1: Graphs showing decline in trip duration and the increase in speed. Note the small difference in east and west bound trips after 1860. The purpose of this case study is to layer a network over a map. For specifics, the script can be found under the ./R directory. The dataset was scraped from a Wikipedia article and geotagged using google maps. There are 119 observations which divide almost equally between eastbound and westbound winners. 10.2 Igraph #import files file &lt;- &quot;./data/rkw/blue_ribald_nodes.csv&quot; nodes &lt;- tibble(data.table::fread(file = file)) file &lt;- &quot;./data/rkw/blue_ribald_edges.csv&quot; edges &lt;- tibble(data.table::fread(file = file)) #create network for graph g &lt;- igraph::graph_from_data_frame(d = edges, directed = T, vertices = nodes ) 10.2.1 Layout with Kamada-Kawai #plot igraph kk par(mar = c(1, 1, 1, 1)) igraph::plot.igraph(g, axes = F, layout= layout_with_kk, edge.arrow.size = .2, edge.width = E(g)$weight, vertex.size = 5, vertex.shape = &quot;circle&quot;, vertex.frame.color = &quot;white&quot;, vertex.color = &quot;skyblue&quot;, vertex.label.cex = .75, vertex.label.dist = -1.3, margin = c(0, 0, 0, 0), asp = 0, main = &quot;Blue Riband Ports&quot; ) Figure 10.2: Note that the inter-nodal distace is maximized where the nodes have the most connections. Here, it is between Sandy Hook (New York harbor) and Queenstown. 10.2.2 Layout with Fruchterman-Reingold This plot is from the same code as above but with layout set to layout = layout_with_fr. Figure 10.3: Note that the inter-nodal distace is minimized where the nodes have the most connections. Here, the shortest path is between Sandy Hook (New York harbor) and Queenstown. 10.3 Geosphere While the above plots are helpful in understanding the frequency of connections between the different ports, they lack the insight that a map could bring to the discussion. The next plot utilizes the geosphere package and is taken from a tutorial by Dr. Nathan Yau at www.flowingdata.com. library(maps) library(geosphere) pal &lt;- colorRampPalette(c(&quot;#333333&quot;, &quot;white&quot;, &quot;#1292db&quot;)) colors &lt;- pal(100) #map(&quot;world&quot;) xlim &lt;- c(-80, 10) ylim &lt;- c(30, 60) map(&quot;world&quot;, col=&quot;#191919&quot;, fill=TRUE, bg=&quot;#000000&quot;, lwd=0.05, mar = c(0, 0, 0, 0), xlim=xlim, ylim=ylim ) edges &lt;- dplyr::arrange(edges, weight) maxcnt &lt;- max(edges$weight) for (i in 1:nrow(edges)) { port1 &lt;- nodes[nodes$id == edges[i,]$from,] port2 &lt;- nodes[nodes$id == edges[i,]$to,] inter &lt;- gcIntermediate(c(port1[1,]$lon, port1[1,]$lat), c(port2[1,]$lon, port2[1,]$lat), n=100, addStartEnd=TRUE) colindex &lt;- round( (edges[i,]$weight / maxcnt) * length(colors) ) lines(inter, col=colors[colindex], lwd=2) } Figure 10.4: Paths over north Atlantic Ocean by blue riband winners. The ‘blue’ path was the one most commonly taken between Queenstown and Sandy Hook. 10.4 NetworkD3 Package The networkD3 package was created on the D3.js framework by Michael Bostock. It provides an easy way to allow for movement of the nodes. # Create graph networkD3::simpleNetwork(edges, linkDistance = 10, charge = -500) Figure 10.5: Hello Resources: The Blue Ribbon or Riband (Hales Trophy) "],["glossary.html", "Chapter 11 Glossary", " Chapter 11 Glossary Great resource here. Attributes are a characteristic of the node or edge that is often designated by color, size, or shape of the object. For example, a dashed line for an edge or a blue circle for a node. Degree the number of nodes adjacent to the node under evaluation or the number of lines incident to it. Deterministic is a algorithm that always produces the same layout for the same graph. Diameter is the maximum number of edges. Edges are ties, relations or connections between nodes. Edges are often designated as \\(E\\). Empty graph is a graph with no vertices or edges. Indegree is the number of received ties. Loops are edges the starting point and the end point is the same node. Multigraph is one where there are multiple edges connecting the same two nodes. Neighborhood of a vertex v in a graph G is the set of vertices adjacent to v. The neighborhood is denoted N(v). The neighborhood does not include v itself. Networks Network objects is a class of objects in R designed specifically for network analysis. They store an adjacency matrix or an edgelist as well as metadata. Nodes are also actors or vertices. They are things like people, places, ideas that have some connection. In mathmatical formulas, they often take the variable \\(N\\). Outdegree the number of sent ties. Directed networks Sociogram is a graph of a network. Trival graph a graph with only one vertex and no edges. Weighted graph or edge-weighted graph is where the edge list contains a variable assigning the strength or “weight” of the connection. "],["igraphdata-plots.html", "A igraphdata Plots A.1 Bridges of Koenigsburg A.2 UKfaculty", " A igraphdata Plots A.1 Bridges of Koenigsburg The city of Koenigsberg in Prussia (now Kaliningrad, Russia) was set on both sides of the Pregel River, and included two large islands which were connected to each other and the mainland by seven bridges. The problem was to find a walk through the city that would cross each bridge once and only once. The islands could not be reached by any route other than the bridges, and every bridge must have been crossed completely every time (one could not walk half way onto the bridge and then turn around and later cross the other half from the other side). Euler proved that the problem has no solution. A.2 UKfaculty The personal friendship network of a faculty of a UK university, consisting of 81 vertices (individuals) and 817 directed and weighted connections. The school affiliation of each individual is stored as a vertex attribute. This dataset can serve as a testbed for community detection algorithms. data(&quot;UKfaculty&quot;) V(UKfaculty)[1:5] ## + 5/81 vertices, from 6f42903: ## [1] 1 2 3 4 5 E(UKfaculty)[1:5] ## + 5/817 edges from 6f42903: ## [1] 57-&gt;52 76-&gt;42 12-&gt;69 43-&gt;34 28-&gt;47 par(mar = c(0, 0, 0, 0)) set.seed(1234) plot.igraph(UKfaculty, vertex.size = 1, layout = layout_with_drl, edge.arrow.width = .1, asp = 0 ) "],["top-10-network-packages-in-r.html", "B Top 10 Network Packages in R", " B Top 10 Network Packages in R Figure B.1: Figure to left shows igraph downloads to total downloads. Figure to right, with y-axis scale and labels changed, shows igraph downloads relative to other network packages. Table B.1: Top 10 Network Packages by download sorted in descending order. package downloads summary igraph 245947 Routines for simple graphs and network analysis. It can handle large graphs very well and provides functions for generating random and regular graphs, graph visualization, centrality methods and much more. ggraph 38914 The grammar of graphics as implemented in ggplot2 is a poor fit for graph and network visualizations due to its reliance on tabular data input. ggraph is an extension of the ggplot2 API tailored to graph visualizations and provides the same flexible approach to building up plots layer by layer. graphlayouts 32993 Several new layout algorithms to visualize networks are provided which are not part of ‘igraph’. Most are based on the concept of stress majorization by Gansner et al. (2004) &lt;doi:10.1007/978-3-540-31843-9_25&gt;;. Some more specific algorithms allow to emphasize hidden group structures in networks or focus on specific nodes. visNetwork 32943 Provides an R interface to the ‘vis.js’ JavaScript charting library. It allows an interactive visualization of networks. sna 22029 A range of tools for social network analysis, including node and graph-level indices, structural distance and covariance methods, structural equivalence detection, network regression, random graph generation, and 2D/3D network visualization. DiagrammeR 20429 Build graph/network structures using functions for stepwise addition and deletion of nodes and edges. Work with data available in tables for bulk addition of nodes, edges, and associated metadata. Use graph selections and traversals to apply changes to specific nodes or edges. A wide selection of graph algorithms allow for the analysis of graphs. Visualize the graphs and take advantage of any aesthetic properties assigned to nodes and edges. influenceR 16695 Provides functionality to compute various node centrality measures on networks. Included are functions to compute betweenness centrality (by utilizing Madduri and Bader’s SNAP library), implementations of Burt’s constraint and effective network size (ENS) metrics, Borgatti’s algorithm to identify key players, and Valente’s bridging metric. On Unix systems, the betweenness, Key Players, and bridging implementations are parallelized with OpenMP, which may run faster on systems which have OpenMP configured. threejs 12920 Create interactive 3D scatter plots, network plots, and globes using the ‘three.js’ visualization library (&lt;https://threejs.org&gt;;). networkD3 11508 Creates ‘D3’ ‘JavaScript’ network, tree, dendrogram, and Sankey graphs from ‘R’. d3Network 8427 This packages is intended to make it easy to create D3 JavaScript network, tree, dendrogram, and Sankey graphs from R using data frames. !!! NOTE: Active development has moved to the networkD3 package. !!! "]]
